local script = script
script.Name = ""
getfenv().script = nil
script.Parent = nil
local stance = {}
local g
stance.__index = stance

function stance.init(_g)
	g = _g
	local self = {}
	setmetatable(self, stance)
	return self
end

function stance:start()
	self.animationTracks = {}
	self.statusFolder = g.player.Status
	self.animationTrackGrab = self:getAnimationTrack(g.stats.arbs.grabItemAnimationID)
	self.animationTrackCraft = self:getAnimationTrack(g.stats.arbs.craftItemAnimationID)
	self.animationTrackRestrained = self:getAnimationTrack(g.stats.arbs.restrainedAnimationID)
	self.zoomedIn = false
	self.downed = false
	self.snowWalking = false
	self.covered = false
	self.walking = false
	self.walkSpeed = 16
	self.jumpPower = 50
	self.respawning = false
	self.jumping = false
	self.climbing = false
	self.swimming = false
	self.standing = false
	self.lastSafePosition = self.statusFolder.LastSafePosition.Value
	self.lastDown = tick()
	self.snowstormShown = false
	self.rainShown = false
	self.stormShown = false
	self.lastZoomIn = tick()
	self.animationTrackDowned = nil
	self.animationTracksDowned = {}
	self.animationTracksRestrainedDowned = {}
	self.restrained = false
	self.allowedPositions = {}
	self.cartDragged = nil
	self.crouched = false
	self.crouchIntro = false
	self.crouchOutro = false
	self.dragged = false
	self.bleeding = false
	self.isCold = false
	self.warmingUp = false
	self.floorMaterial = nil
	self.lastCrouch = tick()
	self.usingRadio = false
	self.animationTrackConsumeFood = self:getAnimationTrack(g.stats.arbs.consumeFoodAnimationID)
	self.followingMouse = false
	self.animationTrackWarmthLow = self:getAnimationTrack(g.stats.arbs.warmthLowAnimationID)
	self.animationTrackHeatSourceNearby = self:getAnimationTrack(g.stats.arbs.heatSourceNearbyAnimationID)
	self.animationTrackSnowstormCover = self:getAnimationTrack(g.stats.arbs.snowstormCoverAnimationID)
	self.animationTrackDragCart = self:getAnimationTrack(g.stats.arbs.dragCartAnimationID)

	self.humanoidState = g.humanoid:GetState()

	g.character.Parent = g.playerMouseFilter

	self:setupHumanoidState()
	self:setupRestrictions()
	self:setupDownedAnimations()
	self:followMouse()
	self:animateSnow()
	self:waitForUpdate()
end

function stance:waitForUpdate()
	game:GetService("ReplicatedStorage"):WaitForChild("TNF").Resources.Binables.SetUpWS.Event:Connect(function(a1,a2)
		if a2 then
			self.crouchIntro = true
			self:updateWalkSpeed()
		elseif a1 then
			self.crouched = true
			self.crouchIntro = false
			self:updateWalkSpeed()
		elseif not a1 and not a2 then
			self.crouched = false
			self.crouchIntro = false
			self.crouchOutro = true
			self:updateWalkSpeed()
		end
	end)
end

function stance:setupRestrictions()
	self.statusFolder.Downed.Changed:connect(function()
		if self.statusFolder.Downed.Value then
			self:down()
		else
			self:revive()
		end
	end)

	self.statusFolder.LastSafePosition.Changed:Connect(function()
		self.lastSafePosition = self.statusFolder.LastSafePosition.Value
	end)

	self.statusFolder.Dragged.Changed:connect(function()
		if self.statusFolder.Dragged.Value then
			self:dragStart()
		else
			self:dragEnd()
		end
	end)

	self.statusFolder.inCombat.Changed:Connect(function()
		local CombatState = self.statusFolder.inCombat.Value

		--[[if self.statusFolder.Quests.QuestTaken.Value == true then
			return
		end]] -- Quests

		if CombatState == true then
			g.interface:showCombatLogIndicator()
		else
			g.interface:hideCombatLogIndicator()
		end
	end)

	--[[self.statusFolder.Quests.QuestTaken.Changed:Connect(function()
		local QuestsTakenState = self.statusFolder.Quests.QuestTaken.Value

		g.interface:hideNotificationIndicator()
		g.interface:hideCombatLogIndicator()

		if QuestsTakenState == true then
			g.interface:showQuestStatusIndicator()
		else
			g.interface:hideQuestStatusIndicator()
		end
	end)]] -- Quests

	self.statusFolder.Bleed.Changed:Connect(function()
		if self.statusFolder.Bleed.Value > 0 then
			self.bleeding = true
			g.interface:showBleeding()
		else
			self.bleeding = false
			g.interface:hideBleeding()
		end
	end)
end

function stance:grab()
	self.animationTrackGrab:Play()
end

function stance:consumeFood(itemName)
	self.animationTrackConsumeFood:Play()
	coroutine.wrap(g.misc.request)("consume", itemName)
end

function stance:craft()
	self.animationTrackCraft:Play()
end

function stance:setupHumanoidState()
	g.humanoid.AutoJumpEnabled = false
	g.humanoid.StateChanged:connect(function(oldHumanoidState, newHumanoidState)
		self.humanoidState = newHumanoidState
		self.walking = self.humanoidState == Enum.HumanoidStateType.Running
		self.falling = self.humanoidState == Enum.HumanoidStateType.Freefall
		self.climbing = self.humanoidState == Enum.HumanoidStateType.Climbing
		self.jumping = self.humanoidState == Enum.HumanoidStateType.Jumping
		self.swimming = self.humanoidState == Enum.HumanoidStateType.Swimming
		if self.humanoidState == Enum.HumanoidStateType.Jumping then
			self:jump()
		elseif self.humanoidState == Enum.HumanoidStateType.Seated then
			self.seated = true
			g.interface:addControl(g.stats.controlNames.stand, g.stats.controls.stand)
			self:endStances()
			delay(5, function()
				if self.seated then
					g.interface:newHint("Press " .. string.upper(g.stats.controls.stand) .. " to stand")
				end
			end)
		else
			if self.seated then
				self.seated = false
				g.interface:removeControl(g.stats.controlNames.stand)
				g.player.CameraMode = Enum.CameraMode.Classic
				g.humanoid.CameraOffset = g.stats.arbs.cameraOffset
				self:zoomOut()
				g.interface:hideBarber()
			end
		end
	end)
	self:updateSnowWalking()
	g.humanoid.Changed:Connect(function()
		self:updateSnowWalking()
	end)
end

function stance:updateSnowWalking()
	self.walking = g.humanoid.MoveDirection ~= Vector3.new(0, 0, 0)
	local snowWalking = g.humanoid.FloorMaterial == Enum.Material.Grass
		or g.humanoid.FloorMaterial == Enum.Material.LeafyGrass
		or g.humanoid.FloorMaterial == Enum.Material.Snow and self.walking
	if snowWalking ~= self.snowWalking then
		self.snowWalking = snowWalking
		coroutine.wrap(g.misc.request)(
			"setInGrass",
			g.humanoid.FloorMaterial == Enum.Material.Grass
				or g.humanoid.FloorMaterial == Enum.Material.LeafyGrass and not self.respawning,
			self.walking and not self.respawning
		)
		self.floorMaterial = g.humanoid.FloorMaterial
		self:updateWalkSpeed()
	end
	if self.cartDragged then
		if self.walking and not self.cartDragged.model.PrimaryPart.Roll.IsPlaying then
			self.cartDragged.model.PrimaryPart.Roll:Play()
		elseif not self.walking then
			self.cartDragged.model.PrimaryPart.Roll:Stop()
		end
	end
end

function stance:setupDownedAnimations()
	for i, v in pairs(g.stats.arbs.downedAnimationIDs) do
		self.animationTracksDowned[i] = self:getAnimationTrack(v)
	end
end

function stance:down()
	if not self.downed then
		self.downed = true
		self.lastDown = tick()
		self.animationTrackDowned = self.animationTracksDowned[math.random(1, #self.animationTracksDowned)]
		self.animationTrackDowned:Play()
		self:updateWalkSpeed()
		self:standH()
		g.interface:hideToolbar()
		g.interface:hideIntegrity()
		self:endStances()
		g.interface:showRespawn()
	end
end

function stance:revive()
	if self.downed then
		self.downed = false
		self.animationTrackDowned:Stop()
		self:updateWalkSpeed()
		if g.player.Status.Tutorial.TutorialStarted.Value == false then
			g.interface:showToolbar()
			g.interface:showIntegrity()
		end
		g.interface:hideRespawn()
	end
end

function stance:requestRespawn(force)
	if (self.downed or force) and tick() - self.lastDown > g.stats.places[game.PlaceId].respawnCooldown then
		self:respawn()
	end
end

function stance:getAnimationTrack(animationID)
	if animationID == nil then
		return nil
	end

	if animationID then
		for i, v in pairs(self.animationTracks) do
			if v.Animation.AnimationId == g.stats.arbs.assetLink .. tostring(animationID) then
				return v
			end
		end

		local animation = Instance.new("Animation")
		animation.AnimationId = g.stats.arbs.assetLink .. tostring(animationID)
		local animationTrack = g.humanoid:LoadAnimation(animation)
		table.insert(self.animationTracks, animationTrack)
		return animationTrack
	end
end

function stance:cold()
	if not self.isCold then
		self.isCold = true
		self.animationTrackWarmthLow:Play()
		coroutine.wrap(g.misc.request)("setWarmthLow", true)
		self:updateWalkSpeed()
	end
end

function stance:warm()
	if self.isCold then
		self.isCold = false
		self.animationTrackWarmthLow:Stop()
		coroutine.wrap(g.misc.request)("setWarmthLow", false)
		self:updateWalkSpeed()
	end
end

function stance:startWarmUp()
	if not self.warmingUp then
		self.warmingUp = true
		self.animationTrackHeatSourceNearby:Play()
	end
end

function stance:endWarmUp()
	if self.warmingUp then
		self.warmingUp = false
		self.animationTrackHeatSourceNearby:Stop()
	end
end

function stance:followMouse()
	if not self.followingMouse then
		self.followingMouse = true
		g.humanoid.AutoRotate = false
		coroutine.wrap(function()
			while g.runService.RenderStepped and self.followingMouse do
				g.rootPart.CFrame = g.rootPart.CFrame:lerp(
					CFrame.new(
						g.rootPart.Position,
						Vector3.new(g.mouse.Hit.Position.X, g.rootPart.Position.Y, g.mouse.Hit.Position.Z)
					),
					0.1
				)
				task.wait()
			end
		end)()
	end
end

function stance:unfollowMouse()
	if self.followingMouse then
		self.followingMouse = false
		--g.humanoid.AutoRotate = true
	end
end

function stance:animateSnow()
	local snowPart = g.objects.SnowPart:Clone()
	snowPart.Parent = g.playerMouseFilter
	coroutine.wrap(function()
		g.runService:BindToRenderStep("SnowAnimation", Enum.RenderPriority.Last.Value, function()
			snowPart.CFrame = CFrame.new(g.camera.CFrame.p.X, g.camera.CFrame.p.Y + 40, g.camera.CFrame.p.Z)
		end)
		while task.wait(0.5) do
			local ray = Ray.new(g.rootPart.Position, Vector3.new(0, 1, 0).unit * 100)
			local hitObject = workspace:FindPartOnRayWithIgnoreList(ray, { g.mouseFilter, g.characters })
			self.covered = hitObject ~= nil
			if hitObject then
				snowPart.SnowParticleEmitter.Transparency = NumberSequence.new(0.8) 
				self:updateSnowstorm(false)
			else
				snowPart.SnowParticleEmitter.Transparency = NumberSequence.new(0) 
				self:updateSnowstorm(g.storage.Snowstorm.Value)
			end
		end
	end)()

	g.storage.Snowstorm.Changed:Connect(function()
		self:updateSnowstorm(g.storage.Snowstorm.Value, true)
	end)

	g.storage.Default.Changed:Connect(function()
		self:updateSnowstorm(g.storage.Default.Value, false)
	end)

	self:updateSnowstorm(g.storage.Snowstorm.Value)
end

function stance:updateSnowstorm(request, transition)
	if request ~= self.snowstormShown or (not request and transition) then
		local transitionTime
		if transition then
			transitionTime = 15
		else
			transitionTime = 1
		end
		if request then
			self.snowstormShown = true
			g.tweenService:Create(g.playerMouseFilter.SnowPart, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Transparency = 1, Size = Vector3.new(20, 1, 20) }):Play()
			g.tweenService:Create(g.playerMouseFilter.SnowPart.SnowParticleEmitter, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Acceleration = Vector3.new(1, 0, 0) }):Play()
			g.tweenService:Create(g.playerMouseFilter.SnowPart.Snowstorm, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Acceleration = Vector3.new(1, 0, 0) }):Play()
			g.tweenService:Create(g.lighting, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { FogColor = Color3.fromRGB(230, 230, 230) }):Play()
			g.tweenService:Create(g.lighting, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { FogEnd = 500 }):Play()
			g.tweenService:Create(g.sounds.Snowstorm, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Volume = .5 }):Play()
			g.playerMouseFilter.SnowPart.SnowParticleEmitter.Enabled = true
			g.playerMouseFilter.SnowPart.Snowstorm.Enabled = true
			if not g.sounds.Snowstorm.IsPlaying then
				g.sounds.Snowstorm:Play()
			end
			if self.covered then
				g.tweenService:Create(g.sounds.Snowstorm, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Volume = .2 }):Play()
			else
				g.tweenService:Create(g.sounds.Snowstorm, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Volume = .5 }):Play()
			end
			delay(transitionTime, function()
				if g.storage.Snowstorm.Value then
					g.playerMouseFilter.SnowPart.SnowParticleEmitter.LockedToPart = true
					g.playerMouseFilter.SnowPart.SnowParticleEmitter.Speed = NumberRange.new(40, 50)
					if not self.covered then
						g.playerMouseFilter.SnowPart.Snowstorm.Enabled = true
						self.animationTrackSnowstormCover:Play()
					end
				end
			end)
		else
			--// snowstorm has ended
			self.snowstormShown = false
			if g.storage.Snowstorm.Value then
				g.tweenService:Create(g.sounds.Snowstorm, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Volume = .1 }):Play()
			else
				g.tweenService:Create(g.lighting, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { FogColor = Color3.fromRGB(139, 140, 145) }):Play()
				g.tweenService:Create(g.sounds.Snowstorm, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Volume = 0 }):Play()
				g.tweenService:Create(g.playerMouseFilter.SnowPart, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Transparency = 1, Size = Vector3.new(200, 1, 200) }):Play()
				g.playerMouseFilter.SnowPart.SnowParticleEmitter.Speed = NumberRange.new(7, 10)
			end
			g.tweenService:Create(g.interface.snowstormBlur, TweenInfo.new(transitionTime, Enum.EasingStyle.Linear), { Size = 0 }):Play()
			g.playerMouseFilter.SnowPart.Snowstorm.Enabled = false
			g.playerMouseFilter.SnowPart.SnowParticleEmitter.Enabled = false
			self.animationTrackSnowstormCover:Stop()
			delay(transitionTime, function()
				if not g.storage.Snowstorm.Value then
					g.playerMouseFilter.SnowPart.SnowParticleEmitter.LockedToPart = false
					g.sounds.Snowstorm:Stop()
				end
			end)
		end
	end
end



function stance:standH()
	local safePosition
	local seatReset
	local seat
	for i, v in pairs(g.operables) do
		if v.model:FindFirstChild("Seat") and v.model.Seat.Occupant == g.humanoid then
			safePosition = v.statusFolder.SafePosition.Value
			seatReset = v.statusFolder.SeatPosition.Value
			seat = v.model:FindFirstChild("Seat")
		end
	end
	g.humanoid.Sit = false
	if safePosition then
		g.rootPart.CFrame = CFrame.new(safePosition)
	end
	if seat and seatReset then
		seat.CFrame = seatReset
	end
end

function stance:dragStart()
	if not self.dragged then
		self.dragged = true
		self:updateWalkSpeed()
	end
end

function stance:dragEnd()
	if self.dragged then
		self.dragged = false
		self:updateWalkSpeed()
	end
end

function stance:jump()
	if g.humanoid.JumpPower > 0 then
		g.integrity:depleteStamina(g.stats.arbs.jumpStaminaCost)
		if g.inventory.itemDrawn and g.inventory.itemDrawn.stats.weapon then
			g.inventory.itemDrawn:unaim()
		end
		task.wait(0.2)
		self.jumpPower = 0
		g.humanoid.JumpPower = self.jumpPower
		task.wait(g.stats.arbs.jumpDebounceTime - 0.2)
		self:updateWalkSpeed()
	end
end

function stance:canDoAction()
	return not g.interface.menuShown
		and not self.downed
		and not self.cartDragged
		and not self.sprinting
		and not self.seated
		and not g.interface.inventoryShown
		and not g.interface.craftingShown
		and not g.interface.travellingShown
		and not g.interface.shopShown
		and not g.interface.stocksShown
		and not g.interface.bankShown
		and not g.interface.tradingPostShown
		and not g.interface.islandsShown
		and not g.interface.bountiesShown
		and not g.interface.factionsShown
		and not g.interface.questShown
		and not g.interface.settingsShown
		and not g.interface.storeShown
		and not g.interface.noticeBoardShown
		and not g.interaction.interacting
end

function stance:updateWalkSpeed()
	if self.dragged and not self.crouched then
		self:unfollowMouse()
		self.walkSpeed = 20
		self.jumpPower = 0
	elseif g.player.Status.CurrentlyTrapped.Value == true then
		self.walkSpeed = 0
		self.jumpPower = 0
	elseif self.downed then
		self:unfollowMouse()
		self.crouchIntro = false
		self.crouchOutro = false
		self.crouched = false
		self.walkSpeed = 0
		self.jumpPower = 0
	elseif self.crouchIntro then
		self.walkSpeed = 0
		self.jumpPower = 0
	elseif self.crouchOutro then
		task.spawn(function()
			self.walkSpeed = 0
			self.jumpPower = 0
			task.wait(.2)
			self.crouchOutro = false
			stance:updateWalkSpeed()
		end)
	elseif g.inventory.itemDrawn and g.inventory.itemDrawn.aiming then
		self:followMouse()
		self.walkSpeed = 2
		self.jumpPower = 0
	elseif self.crouched then
		self.walkSpeed = 5
		self.jumpPower = 0
	elseif g.player.Status.Slowed.Value == true then
		self.walkSpeed = 5
		self.jumpPower = 0
	elseif self.cartDragged then
		self:unfollowMouse()
		g.humanoid.AutoRotate = true
		if self.snowWalking then
			self.walkSpeed = 9
		else
			self.walkSpeed = 11
		end
		self.jumpPower = 0
	elseif
		not self:canDoAction()
		and not g.interface.bankShown
		and not g.interface.tradingPostShown
		and not g.interface.shopShown
		and not g.interface.noticeBoardShown
	then
		self:unfollowMouse()
		self.walkSpeed = 0
		self.jumpPower = 0
	elseif g.interface.shopShown or g.interface.bankShown or g.interface.tradingPostShown and not self.crouched  then
		self:unfollowMouse()
		self.walkSpeed = 10
		self.jumpPower = 0
	elseif self.restrained then
		self:unfollowMouse()
		self.walkSpeed = 5
		self.jumpPower = 0
	else
		self:followMouse()
		local interior = false
		for i, v in pairs(g.loadedZones) do
			if v.stats.interior then
				self.walkSpeed = 12
				self.jumpPower = 0
				interior = true
				break
			end
		end
		if not interior then
			self.walkSpeed = 14
			self.jumpPower = 50
			if g.inventory.itemDrawn and g.inventory.itemDrawn.stats.walkSpeedPenalty then
				self.walkSpeed = self.walkSpeed - g.inventory.itemDrawn.stats.walkSpeedPenalty
			end
		end
		if g.inventory.full then
			self.walkSpeed = math.min(6, self.walkSpeed)
			self.jumpPower = 0
		elseif not g.integrity.staminaAvailable then
			self.walkSpeed = math.min(12, self.walkSpeed)
			self.jumpPower = 0
		elseif g.inventory.itemDrawn and g.inventory.itemDrawn.reloading then
			self:followMouse()
			self.walkSpeed = math.min(10, self.walkSpeed)
			self.jumpPower = 0
		elseif self.floorMaterial == Enum.Material.Snow then
			self:followMouse()
			
			local snowshoesColonialWalkSpeed = 12
			local snowshoesNativeWalkSpeed = 13
			
			local baseColonialWalkSpeed = 10
			local baseNativeWalkSpeed = 12
			
			local newWalkSpeed
			local baseWalkSpeed
			
			if g.player.Status.Role.Value == "Native" then
				newWalkSpeed = snowshoesNativeWalkSpeed
				baseWalkSpeed = baseNativeWalkSpeed
			else
				newWalkSpeed = snowshoesColonialWalkSpeed
				baseWalkSpeed = baseColonialWalkSpeed
			end
			
			if g.inventory:getEquippedTypeItem("snowshoes") then
				self.walkSpeed = math.min(newWalkSpeed, self.walkSpeed)
				self.jumpPower = math.min(50, self.jumpPower)
			elseif g.inventory:getEquippedTypeItem("scuffedsnowshoes") then
				self.walkSpeed = math.min(newWalkSpeed, self.walkSpeed)
				self.jumpPower = math.min(50, self.jumpPower)
			else
				self.walkSpeed = math.min(baseWalkSpeed, self.walkSpeed)
				self.jumpPower = math.min(40, self.jumpPower)
			end
		elseif g.integrity.warmthLow then
			self.walkSpeed = math.min(11, self.walkSpeed)
			self.jumpPower = math.min(40, self.jumpPower)
		end
	end
	g.humanoid.WalkSpeed = math.max(0, self.walkSpeed)
	g.humanoid.JumpPower = math.max(0, self.jumpPower)
end

function stance:endStances()
	g.inventory:holsterItem()
	g.interface:hideInventory()
	g.interface:hideCrafting()
	g.interface:hideShop()
	g.interface:hideTravelling()
	g.interface:hideLoot()
	g.interface:hideBank()
	--g.interface:hideQuests() Quests
	g.interface:hideSettings()
	g.interface:hideTradingPost()
	g.interface:hideStorage()
	g.interface:hideCabinet()
	g.interface:hideIslands()
	g.interface:hideBounties()
	g.interface:hideFactions()
	g.interface:hideStore()
	g.interaction:deployItemEnd()
	g.interaction:dragItemEnd()
	g.interaction:reset()
	self:dropCart(true)
end

function stance:respawn(firstRespawn)
	if not self.respawning then
		self.respawning = true
		if firstRespawn then
			g.integrity:_start()
			g.character.Parent = g.playerMouseFilter
			g.camera.CameraSubject = g.humanoid
			g.camera.CameraType = Enum.CameraType.Custom
		else
			local spawnPosition = g.player.Status.SpawnPosition.Value
			for i, v in pairs(g.operables) do
				if v.type == "spawn" and v.statusFolder.Owner.Value == g.player then
					spawnPosition = v.statusFolder.SpawnPosition.Value
					break
				end
			end

			g.player.Status.inCombat.Value = false
			g.player.Status.CombatLog.Value = 0
			g.interface:showTransition()
			g.misc.request("respawnPlayer")
			self:revive()
			g.integrity:setHunger(g.stats.arbs.defaultMaxHunger)
			g.integrity:setWarmth(g.stats.arbs.defaultMaxWarmth)
			g.interface:hideTransition()
		end
		self:updateSnowWalking()
		self:updateWalkSpeed()
		self.respawning = false
	end
end

function stance:useOperable()
	self.animationTrackUseOperable:Play()
end

function stance:zoomIn()
	if not self.zoomedIn and self.seated and not g.interface.stocksShown then
		self.lastZoomIn = tick()
		self.zoomedIn = true
		g.tweenService:Create(g.camera, TweenInfo.new(0.4), { FieldOfView = g.stats.arbs.zoomedInFieldOfView }):Play()
	end
end

function stance:zoomOut()
	if self.zoomedIn then
		self.zoomedIn = false
		g.tweenService:Create(g.camera, TweenInfo.new(0.4), { FieldOfView = g.stats.arbs.defaultFieldOfView }):Play()
	end
end

function stance:dragCart(operable)
	self:endStances()
	self.cartDragged = operable
	self.animationTrackDragCart:Play()
	self:updateWalkSpeed()
	g.interface:addControl(g.stats.controlNames.dropCart, g.stats.controls.dropCart)
end

function stance:dropCart(forced)
	if self.cartDragged and (forced or not self.falling) then
		self.cartDragged:dropCart()
		self.cartDragged = nil
		self.animationTrackDragCart:Stop()
		self:updateWalkSpeed()
		g.interface:removeControl(g.stats.controlNames.dropCart)
	end
end

return stance
